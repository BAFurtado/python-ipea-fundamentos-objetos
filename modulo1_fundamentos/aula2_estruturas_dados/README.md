<style>

</style>
 
<header>
   <a href="https://bafurtado.github.io/python-ipea-fundamentos-objetos/">
 <img id = "cabeca" src ="{{ site.baseurl }}/images/banner.png">
 </a>
</header>

# Aula 2

### Endere√ßos
- Curso: [https://bafurtado.github.io/python-ipea-fundamentos-objetos](https://bafurtado.github.io/python-ipea-fundamentos-objetos/)
- Reposit√≥rio git com os arquivos: [https://github.com/baFurtado/python-ipea-fundamentos-objetos/](https://github.com/baFurtado/python-ipea-fundamentos-objetos/)

**Aula 1--recapitulando**
- Instala√ß√£o?
- Console
- Script `python meu_script.py`
- Operadores, `type`
- No√ß√µes de objetos em **Python**


## Cont. Aula 1

4. `help()`

## Strings

1. Strings, como listas (que veremos) s√£o uma sequ√™ncia
2. Com isso, podem ser acessadas por meio de indexes
    - Lembre-se: em **python** indexing come√ßa em 0.
    Logo: 
    ```python
    frase = 'python is cool'
    frase[1]  # ?
    ```
### Acessando itens (em strings e listas)

1. Use index, mas come√ße pelo **0**   `# como maioria das "linguagens" de programa√ß√£o`
2. *MUTABLE*: Quando voc√™ "assign" um valor novo, ele substitui o anterior

```python
>>> supermercado = ['banana', 'ovos', 'alface', 'leite']
>>> supermercado[2] = 'r√∫cula'
>>> supermercado

# What happens for supermercado[-1] ?
```

1. **Sobre iterables e indexes**
    - dois pontos (colon) s√£o importantes dentro de colchetes para indexes
        - [in√≠cio:fim(n√£o inclu√≠do)]
        - **[4:7]** do ent√£o 4 at√© o antes do 7
            - note que o 7o. termo est√° inclu√≠do porque come√ßou em 0
        - in√≠cio omitido √© 0
        - fim omitido √© o √∫ltimo -1
        - logo **[:]** √© a lista toda
 
 ```python
 # simples √© uma lista para ficar mais visual a posi√ß√£o (listas -> aula2)
 simples = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
 
 Teste no console
 ```python
 simples[0]
 simples[-1]
 simples[4]
 simples[:4]
 simples[:]
 simples[-2:]
 simples[:-2]
 simples[-2:-2]
 # be careful
 simples[10]
 # note que s√≥ acessamos os itens. n√£o modificamos as listas
 # m√©todos, todavia, alteram a lista inplace
 ```

### Strings--methods

```python
motivator = 'python is cool'
type(motivator)
motivator.capitalize()
help(str)
# endswith, isnum, isalpha, islower, isupper, join, 
# lower, split,s trip, title, zfill
motivator[6]
motivator.split(' ')

subject, verb, adjective = motivator.split(' ')
sintaxe_tuple = motivator.split(' ')

CNPJ_BB = 191
# be carefult
CNPJ_BB.zfill(14)
# what is the error?
# ...

str(CNPJ_BB).zfill(14)
```

## Reserved words

<img src="{{ site.baseurl }}/images/keywords.png">

## Built-in functions


<img src="{{ site.baseurl }}/images/builtin.png">


[Fonte imagens/Credit: 30 Days of Python](https://github.com/Asabeneh/30-Days-Of-Python/tree/master)

## C√≥digo pythonico

- **Cuidado com seu self futuro**
<img src="{{ site.baseurl }}/images/meme.png">
- ### [PEP 8 -- Jeito pythonista de ser](pep8-python-style-guide.md)

### Boas pr√°ticas--DRY: don't repeat yourself
www.greenteapress.com/thinkpython/html/thinkpython005.html
1. **Encapsulation**

    *Wrapping a piece of code up in a function is called encapsulation. One of the benefits of encapsulation is that it attaches a name to the code, which serves as a kind of documentation. Another advantage is that if you re-use the code, it is more concise to call a function twice than to copy and paste the body!*
            
2. **Generalization**

    *Adding a **parameter** to a function is called generalization because it makes the function more general*

### For Fun

1. `import antigravity`
2. `import this`
3. [**Gamification I**](https://py.checkio.org)
4. [**Gamification II**](http://www.pythonchallenge.com/pc/def/0.html)
5. [Automatizando uma fazenda com **Python**](https://store.steampowered.com/app/2060160/The_Farmer_Was_Replaced/)

### [Links √öteis]({{ site.baseurl }}/referencias/)

### Exerc√≠cios

1. Quanto √© '5' * 5?
2. `print(5 + 5)` √© igual a `print('5' + '5')`? Why?
3. Quanto √© :  `(25 ‚àó (2 + 23)/54)2`
4. Quantas horas inteiras tem em 200 minutos? Use `//` floor division
5. Quantos minutos sobram? Use `%` remainder

# Aula 2

Goal: Listas, tuplas, dicion√°rios, conjuntos e suas opera√ß√µes principais. Exerc√≠cios

## Listas--mutable--iterable 

 - sequ√™ncia (strings tamb√©m)

```python
notas_curso = [0, 0, 1, 0, 3, 0, 2, 0, 9, 8]  # ;)
supermercado = ['banana', 'ovos', 'alface', 'leite']
total_mess = ['aulas', 43, ['October', 16]]
empty_list = list()
empty_list2 = []
```

### M√©todos

1. `append(item)`  # appends to the end of the list
2. `pop()`  # returns last item
3. `sort()`  # accepts parameter `reverse` 
4. outras?

5. Apply **python** general functions to lists

```python
len(simples)
sum(simples)
# outras?
```
### Gotcha!

```python

a = [1, 2, 3]
b = a
a.append(4)
# What is the value of b?
# is serve para testar se o objeto √© o mesmo
a is b
# id() √© uma fun√ß√£o que identifica o n√∫mero individual do objeto na mem√≥ria
id(a)
id(b)
```

### Fun thing (relacionada)
```python
a, b = 1, 2
# quais valores de a e de b?
a, b = b, a
# e agora?

# revisite total_mess
# o que total_mess[2][1] retorna?
```

## Tuplas (tuples)--immutable

```python
luck_numbers = (43, 16, 88)
type(luck_numbers)
help(luck_numbers)
16 in luck_numbers
69 in luck_numbers
luck_numbers.count(16)
luck_numbers[1]
```
1. Indexes igual √† listas. 
2. Por√©m, imut√°vel -> n√£o recebe assignment  # Wrong: `t[0] = 9`

### Cool example: tuple + str method
```python
# introducing string formatting on the fly and join :)
print(f'join is {'super'.upper()} cool string method')
# systematics. print + f + single or double quotes + variable between brackets: 
print(f"this f-string works and is {adjective}")  
# as long as adjective exists in the namespace

# very common example tupla para assignment
hora = 60  # padr√£o
minutos = 200  # para transformar em horas e minutos

horas, minutos = minutos // hora, minutos % hora
```

## Dicion√°rios key: value--muit√≠ssimo √∫til--fast-indexado--mapping
```python
# Cria-se com CHAVES
# Par chave, valor com dois pontos
# Assign como listas, com colchetes--chave = valor

armario1 = {}
armario1 = dict()  # tamb√©m funciona. Acho mais expl√≠cito
key = 'gavetao'
value = 'len√ß√≥is especiais'

# √â necess√°rio ter criado o dicion√°rio antes. 
# Mesma coisa com append para lista.
armario1[key] = value
armario1
armario2 = {key: value}
armario2
armario3 = {'gavetao': 'len√ß√≥is especiais'}
armario3

armario1 == armario2 == armario3
armario1 is armario2
```

### M√©todos

1. `armario1.keys()`  # chaves
2. `armario1.values()`  # valores
3. `armario1.items()`  # lista de tuples de chaves e valores 

    ```python
    armario1['gaveta_alta`] = 'pijamas
    [(key1, value1), (key2, value2)]
    armario1['gaveta_alta`] = 'pijamas
    ```

## Fun thing: salto ao futuro (das aulas)
### ü§î good idea?

```python


def histogram(string): 
    """ Exemplo de dicion√°rio como uma fun√ß√£o para contagem: histogram. 
    Inclui par√¢metro de input, retorna dicion√°rio criado, faz loop e testa condicional. 
    Muita calma nessa hora!
    """
    # Cria o dicion√°rio
    meu_dict = dict()
    # Come√ßa o loop pelas letras da palavra
    for letter in string:
        # Testa se a letra j√° est√° no dicion√°rio
        if letter not in meu_dict:
            # Inicia contagem
            meu_dict[letter] = 1
        # Se ela j√° estava, aumenta a contagem em 1
        else:
            meu_dict[letter] += 1
    # Depois do loop retorna o dicion√°rio pronto
    return meu_dict

# Para chamar a fun√ß√£o
palavra_teste = 'abracadabra'
resposta = histogram(palavra_teste)

```

## Sets--Conjuntos--elementos √∫nicos!

```python
conjunto = set()
outro_conjunto = {87, 91, 88}  # Chaves, mas n√£o para chave-valor. 
""" unordered, unchangeable, no duplicate values"""
# Method
conjunto.add(88)  # N√£o √© append, como lista, √© ADD
print(len(conjunto))
conjunto.add(88)
print(len(conjunto))
conjunto.add(81)
```

### Methods
 - `in` `88 in conjunto`
 - `conjunto.update(outro_conjunto)`  # tamb√©m pode update com uma lista
 - `uniao = conjunto.union(outro_conjunto)`  # retorna um set
 - `conjunto.intersection(outro_conjunto)`  # mant√©m s√≥ os elementos, presentes em ambos, retorna um set
 - `diferenca = conjunto.difference(outro_conjunto)`  # retorna a diferen√ßa

### Vida pr√°tica--eliminar duplicates

`lista_elementos_unicos = list(set(lista_com_duplicados))`




